### 堆
可以用一颗完全二叉树来描述
假设数组标记i从0到len-1，则 left[i]=2\*i+1  right[i]=2\*i+2;   
反过来：i = (left-1)/2  ; i = (right-1)/2; 这里都是假设i/left/right 取值范围为0到len-1；这里的除2其实是向下取整。
一般使用数据表示

### 堆排序算法描述
堆排序包括以下几个过程：
- 设计max-heap函数   
该函数为关键辅助函数，假设当前处理节点为i，并假设i的两颗子树（如果存在） left[i],right[i]开始的数都是大顶堆（或小顶堆，具体看堆类型）   
则max-heap函数会将节点i插入到子树中，使得满足大顶堆的性质。    
通过计算可以得到该函数的复杂度为T(n)<=T(2/3n)+O(1) 化解后可得 时间复杂度为O(lgn)

- 构建堆   
其实就是从最后一个节点的父节点开始，依次调用max-heap，从而构建成为整个堆

- 排序  
1. 先构造堆
2. 从最后一个元素开始，依次与第一个元素替换，每次替换之后（相当于把第一个元素放置到数组的最后位置），减小相应的数组大小（调整堆大小）,调用max-heap，重构堆（注意堆大小减少）
由于需要调用依次max-heap n次，所以性能为O(nlgn)

## use case
1. Q: 1百万个数中，找出最大的1000个数   
A: 构造一个1000大小的小顶堆，依次添加，每次替换掉顶部最小的数据; 时间复杂度为O(klgn),k为需求的最大个数，n为数组长度
A:  也可以采用选择中位数的计算方法，可以达到O（n）的时间复杂度（该算法有使用快排轴选取的过程）

2. 优先队列如何实现
使用最大堆（最大优先级）或最小堆（最小优先级）
区别在于，优先队列中可能会改变元素的优先级（即值改变），此时需要做调整，调整的方法也类似max-heap，有点逆推的过程，即更新一个值后，需要与该节点的父节点比较，如果满足堆性质，则不改变，否则需要调整，继续调整，直到没有可以调整的元素即可。

